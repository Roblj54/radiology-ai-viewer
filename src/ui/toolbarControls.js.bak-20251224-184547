/**
 * Toolbar Controls Pack (updated)
 * - Results button + badge
 * - Reset View button
 * - Transform controls: Invert, Rotate 90, Flip H, Flip V
 * - Modality badge (CT/MR/OTHER)
 * - Slice counter "current / total"
 * - Cine controls (Play/Pause + FPS + Prev/Next)
 * - Window/Level presets dropdown + manual WL/WW sliders
 * - Modality adaptive presets (CT vs MR)
 * - Auto-publish AI results by intercepting fetch() JSON responses
 *
 * For Reset/Cine/SliceCounter/WL to work reliably:
 *   window.__CS_RENDERING_ENGINE__ = renderingEngine;
 *   window.__CS_VIEWPORT_ID__ = viewportId;
 * Optional (better event-driven slice updates):
 *   window.__CS_ELEMENT__ = elementUsedToEnableTheViewport;
 * Optional (stronger modality detection override):
 *   window.__DICOM_MODALITY__ = "CT" | "MR";
 */

function $(sel, root = document){ return root.querySelector(sel); }
function $all(sel, root = document){ return Array.from(root.querySelectorAll(sel)); }

function safeArray(x){ return Array.isArray(x) ? x : []; }
function toLower(x){ return String(x ?? "").toLowerCase(); }
function normMod(x){ return String(x ?? "").trim().toUpperCase(); }

const store = {
  get(key, fallback = ""){
    try{
      if (typeof localStorage === "undefined" || !localStorage.getItem) return fallback;
      const v = localStorage.getItem(key);
      return (v === null || v === undefined || v === "") ? fallback : v;
    }catch(e){ return fallback; }
  },
  set(key, val){
    try{
      if (typeof localStorage === "undefined" || !localStorage.setItem) return;
      localStorage.setItem(key, String(val));
    }catch(e){}
  }
};

function getCornerstoneContext(){
  return {
    renderingEngine: window.__CS_RENDERING_ENGINE__ || null,
    viewportId: window.__CS_VIEWPORT_ID__ || null
  };
}

function getViewport(){
  const ctx = getCornerstoneContext();
  if (!ctx.renderingEngine || !ctx.viewportId) return null;
  try{
    const vp = ctx.renderingEngine.getViewport(ctx.viewportId) || null;
    return vp;
  }catch(e){
    return null;
  }
}

function getViewportElement(vp){
  if (vp && vp.element) return vp.element;
  if (window.__CS_ELEMENT__) return window.__CS_ELEMENT__;
  return null;
}

/* -------------------------
   AI Results badge wiring
   ------------------------- */
function setBadgeCount(n){
  const el = document.getElementById("aiResultsDockCount");
  if (!el) return;
  el.textContent = String(Math.max(0, Number(n) || 0));
}

function installBadgeWiring(){
  window.addEventListener("ai:results", (e) => {
    const arr = e && e.detail ? e.detail : [];
    setBadgeCount(safeArray(arr).length);
  });

  const t = setInterval(() => {
    if (window.__AI_RESULTS_WRAPPED__) { clearInterval(t); return; }
    if (typeof window.setAIResults === "function") {
      const orig = window.setAIResults;
      window.setAIResults = (findings) => {
        const arr = safeArray(findings);
        setBadgeCount(arr.length);
        return orig(arr);
      };
      window.__AI_RESULTS_WRAPPED__ = true;
      clearInterval(t);
    }
  }, 400);
}

function toggleResultsPanel(){
  const panel = document.getElementById("aiResultsPanel");
  if (!panel) return;

  panel.classList.toggle("is-collapsed");
  const collapsed = panel.classList.contains("is-collapsed");
  panel.style.pointerEvents = collapsed ? "none" : "auto";
  panel.style.opacity = collapsed ? "0" : "1";
}

/* -------------------------
   Slice Counter
   ------------------------- */
function getStackSize(vp){
  try{
    if (vp && typeof vp.getImageIds === "function") {
      const ids = vp.getImageIds();
      return safeArray(ids).length;
    }
  }catch(e){}

  if (Array.isArray(window.__STACK_IMAGE_IDS__)) return window.__STACK_IMAGE_IDS__.length;

  try{
    if (vp && typeof vp.getStack === "function") {
      const st = vp.getStack();
      if (st && Array.isArray(st.imageIds)) return st.imageIds.length;
    }
  }catch(e){}

  return 0;
}

function getCurrentIndex(vp){
  try{
    if (vp && typeof vp.getCurrentImageIdIndex === "function") return Number(vp.getCurrentImageIdIndex()) || 0;
    if (vp && typeof vp.getImageIdIndex === "function") return Number(vp.getImageIdIndex()) || 0;
    if (vp && typeof vp.getCurrentImageIndex === "function") return Number(vp.getCurrentImageIndex()) || 0;
  }catch(e){}
  return 0;
}

function formatCounter(cur, total){
  if (!total || total < 1) return "-- / --";
  const c = Math.min(Math.max(0, cur), total - 1);
  return `${c + 1} / ${total}`;
}

function updateSliceCounter(counterEl){
  if (!counterEl) return;
  const vp = getViewport();
  if (!vp) {
    if (counterEl.textContent !== "-- / --") counterEl.textContent = "-- / --";
    return;
  }

  const total = getStackSize(vp);
  const cur = getCurrentIndex(vp);
  const nextText = formatCounter(cur, total);

  if (counterEl.textContent !== nextText) counterEl.textContent = nextText;
}

function installSliceCounterWiring(counterEl){
  updateSliceCounter(counterEl);

  if (window.__SLICE_COUNTER_TIMER__) clearInterval(window.__SLICE_COUNTER_TIMER__);
  window.__SLICE_COUNTER_TIMER__ = setInterval(() => updateSliceCounter(counterEl), 200);

  const tryHook = () => {
    const vp = getViewport();
    const el = getViewportElement(vp);
    if (!el || !el.addEventListener) return;

    if (window.__SLICE_COUNTER_EVENTS_HOOKED__) return;
    window.__SLICE_COUNTER_EVENTS_HOOKED__ = true;

    const events = [
      "CORNERSTONE_STACK_NEW_IMAGE",
      "CORNERSTONE_STACK_VIEWPORT_SCROLL",
      "CORNERSTONE_VIEWPORT_NEW_IMAGE_SET",
      "CORNERSTONE_IMAGE_RENDERED",
      "CORNERSTONE_VOLUME_NEW_IMAGE"
    ];

    events.forEach(evt => {
      try{ el.addEventListener(evt, () => updateSliceCounter(counterEl)); }catch(e){}
    });
  };

  setTimeout(tryHook, 300);
  setTimeout(tryHook, 1200);

  document.addEventListener("wheel", () => updateSliceCounter(counterEl), { passive: true });
  document.addEventListener("keydown", (e) => {
    const k = String(e.key || "");
    if (k === "ArrowUp" || k === "ArrowDown" || k === "PageUp" || k === "PageDown") {
      updateSliceCounter(counterEl);
    }
  });
}

/* -------------------------
   Reset View
   ------------------------- */
function resetView(){
  const vp = getViewport();
  if (!vp) {
    console.warn("[Reset View] Missing viewport. Set window.__CS_RENDERING_ENGINE__ and window.__CS_VIEWPORT_ID__.");
    return;
  }

  try{
    if (typeof vp.resetCamera === "function") vp.resetCamera();
    if (typeof vp.resetProperties === "function") vp.resetProperties();

    if (typeof vp.setZoom === "function") vp.setZoom(1);
    if (typeof vp.setPan === "function") vp.setPan({ x: 0, y: 0 });

    if (typeof vp.render === "function") vp.render();
  }catch(e){
    console.warn("[Reset View] failed:", e);
  }
}

/* -------------------------
   Modality detection
   ------------------------- */
function modalityClass(mod){
  const m = normMod(mod);
  if (m.startsWith("CT")) return "CT";
  if (m.startsWith("MR")) return "MR";
  return m || "OTHER";
}

function detectModality(){
  const forced = window.__DICOM_MODALITY__ || window.__CS_MODALITY__ || window.__MODALITY__;
  if (forced) return modalityClass(forced);

  const vp = getViewport();
  if (!vp) return "OTHER";

  let imageId = null;
  try{
    if (typeof vp.getImageIds === "function") {
      const ids = vp.getImageIds();
      if (ids && ids.length) imageId = ids[0];
    }
  }catch(e){}

  if (!imageId) return "OTHER";

  const cs = window.cornerstone || window.cornerstonejs || window.cornerstone3d || null;
  const mdGet = cs && cs.metaData && typeof cs.metaData.get === "function" ? cs.metaData.get.bind(cs.metaData) : null;

  if (mdGet) {
    try{
      const gsm = mdGet("generalSeriesModule", imageId);
      if (gsm && (gsm.modality || gsm.Modality)) return modalityClass(gsm.modality || gsm.Modality);
    }catch(e){}
    try{
      const m = mdGet("x00080060", imageId);
      if (m) return modalityClass(m);
    }catch(e){}
  }

  if (window.__CS_METADATA__ && window.__CS_METADATA__.modality) return modalityClass(window.__CS_METADATA__.modality);

  return "OTHER";
}

/* -------------------------
   Transform controls (Invert, Rotate, Flip)
   ------------------------- */
function getPropBool(vp, name){
  try{
    if (vp && typeof vp.getProperties === "function") {
      const p = vp.getProperties();
      if (p && typeof p[name] === "boolean") return p[name];
    }
  }catch(e){}
  return null;
}

function setProp(vp, patch){
  try{
    if (vp && typeof vp.setProperties === "function") {
      vp.setProperties(patch);
      if (typeof vp.render === "function") vp.render();
      return true;
    }
  }catch(e){}
  return false;
}

function getViewPresentation(vp){
  try{
    if (vp && typeof vp.getViewPresentation === "function") return vp.getViewPresentation();
  }catch(e){}
  return null;
}

function setViewPresentation(vp, pres){
  try{
    if (vp && typeof vp.setViewPresentation === "function") {
      vp.setViewPresentation(pres);
      if (typeof vp.render === "function") vp.render();
      return true;
    }
  }catch(e){}
  return false;
}

function toggleInvert(btn){
  const vp = getViewport();
  if (!vp) return;

  // Prefer setProperties if available
  const cur = getPropBool(vp, "invert");
  if (cur !== null) {
    const next = !cur;
    setProp(vp, { invert: next });
    if (btn) btn.classList.toggle("is-active", next);
    return;
  }

  // Fallback: view presentation
  const pres = getViewPresentation(vp);
  if (!pres) return;
  const next = !Boolean(pres.invert);
  pres.invert = next;
  setViewPresentation(vp, pres);
  if (btn) btn.classList.toggle("is-active", next);
}

function rotate90(){
  const vp = getViewport();
  if (!vp) return;

  // Prefer setProperties if available
  try{
    if (vp && typeof vp.getProperties === "function" && typeof vp.setProperties === "function") {
      const p = vp.getProperties() || {};
      const rot = Number(p.rotation) || 0;
      const next = (rot + 90) % 360;
      vp.setProperties({ rotation: next });
      if (typeof vp.render === "function") vp.render();
      return;
    }
  }catch(e){}

  const pres = getViewPresentation(vp);
  if (!pres) return;
  const rot = Number(pres.rotation) || 0;
  pres.rotation = (rot + 90) % 360;
  setViewPresentation(vp, pres);
}

function flipH(btn){
  const vp = getViewport();
  if (!vp) return;

  // Prefer viewPresentation for flips
  const pres = getViewPresentation(vp);
  if (!pres) {
    // fallback setProperties
    try{
      if (vp && typeof vp.getProperties === "function" && typeof vp.setProperties === "function") {
        const p = vp.getProperties() || {};
        const next = !Boolean(p.flipHorizontal);
        vp.setProperties({ flipHorizontal: next });
        if (typeof vp.render === "function") vp.render();
        if (btn) btn.classList.toggle("is-active", next);
      }
    }catch(e){}
    return;
  }

  const next = !Boolean(pres.flipHorizontal);
  pres.flipHorizontal = next;
  setViewPresentation(vp, pres);
  if (btn) btn.classList.toggle("is-active", next);
}

function flipV(btn){
  const vp = getViewport();
  if (!vp) return;

  const pres = getViewPresentation(vp);
  if (!pres) {
    try{
      if (vp && typeof vp.getProperties === "function" && typeof vp.setProperties === "function") {
        const p = vp.getProperties() || {};
        const next = !Boolean(p.flipVertical);
        vp.setProperties({ flipVertical: next });
        if (typeof vp.render === "function") vp.render();
        if (btn) btn.classList.toggle("is-active", next);
      }
    }catch(e){}
    return;
  }

  const next = !Boolean(pres.flipVertical);
  pres.flipVertical = next;
  setViewPresentation(vp, pres);
  if (btn) btn.classList.toggle("is-active", next);
}

/* -------------------------
   Window/Level helpers
   ------------------------- */
function getCurrentVOI(vp){
  if (!vp) return null;
  try{
    if (typeof vp.getProperties === "function") {
      const p = vp.getProperties();
      if (p && p.voiRange && Number.isFinite(p.voiRange.lower) && Number.isFinite(p.voiRange.upper)) {
        return { lower: Number(p.voiRange.lower), upper: Number(p.voiRange.upper) };
      }
    }
  }catch(e){}

  try{
    if (typeof vp.getVOI === "function") {
      const v = vp.getVOI();
      if (v) {
        if (Number.isFinite(v.lower) && Number.isFinite(v.upper)) return { lower: Number(v.lower), upper: Number(v.upper) };
        if (Number.isFinite(v.windowCenter) && Number.isFinite(v.windowWidth)) {
          const lower = Number(v.windowCenter) - (Number(v.windowWidth) / 2);
          const upper = Number(v.windowCenter) + (Number(v.windowWidth) / 2);
          return { lower, upper };
        }
      }
    }
  }catch(e){}

  try{
    if (typeof vp.getWindowLevel === "function") {
      const v = vp.getWindowLevel();
      if (v && Number.isFinite(v.windowCenter) && Number.isFinite(v.windowWidth)) {
        const lower = Number(v.windowCenter) - (Number(v.windowWidth) / 2);
        const upper = Number(v.windowCenter) + (Number(v.windowWidth) / 2);
        return { lower, upper };
      }
    }
  }catch(e){}

  return null;
}

function voiToWL(voi){
  if (!voi || !Number.isFinite(voi.lower) || !Number.isFinite(voi.upper)) return null;
  const ww = voi.upper - voi.lower;
  const wl = (voi.upper + voi.lower) / 2;
  if (!Number.isFinite(ww) || !Number.isFinite(wl) || ww <= 0) return null;
  return { ww, wl };
}

function applyVOIRangeFromWL(ww, wl){
  const vp = getViewport();
  if (!vp) {
    console.warn("[W/L] Missing viewport. Set window.__CS_RENDERING_ENGINE__ and window.__CS_VIEWPORT_ID__.");
    return;
  }

  const width = Number(ww);
  const level = Number(wl);
  if (!Number.isFinite(width) || !Number.isFinite(level) || width <= 0) return;

  const lower = level - (width / 2);
  const upper = level + (width / 2);

  try{
    if (typeof vp.setProperties === "function") {
      vp.setProperties({ voiRange: { lower, upper } });
    } else if (typeof vp.setVOI === "function") {
      vp.setVOI({ windowWidth: width, windowCenter: level });
    } else if (typeof vp.setWindowLevel === "function") {
      vp.setWindowLevel(level, width);
    }
    if (typeof vp.render === "function") vp.render();
  }catch(e){
    console.warn("[W/L] apply failed:", e);
  }
}

function ctPresetToWL(key){
  // Common CT presets (WW/WL)
  if (key === "brain")   return { ww: 70,   wl: 35 };
  if (key === "soft")    return { ww: 350,  wl: 50 };
  if (key === "lung")    return { ww: 1500, wl: -600 };
  if (key === "bone")    return { ww: 2500, wl: 500 };
  if (key === "abdomen") return { ww: 400,  wl: 50 };
  if (key === "liver")   return { ww: 150,  wl: 30 };
  return null;
}

function setSliderRanges(mod, wlSlider, wwSlider){
  if (!wlSlider || !wwSlider) return;

  const vp = getViewport();
  const current = voiToWL(getCurrentVOI(vp));

  if (mod === "CT") {
    wlSlider.min = "-1024";
    wlSlider.max = "3071";
    wlSlider.step = "1";
    wwSlider.min = "1";
    wwSlider.max = "4000";
    wwSlider.step = "1";
    return;
  }

  const wl = current ? current.wl : 0;
  const ww = current ? current.ww : 800;

  const wlMin = Math.floor(wl - 2000);
  const wlMax = Math.ceil(wl + 2000);
  const wwMax = Math.ceil(Math.max(2000, ww * 3));

  wlSlider.min = String(wlMin);
  wlSlider.max = String(wlMax);
  wlSlider.step = "1";

  wwSlider.min = "1";
  wwSlider.max = String(wwMax);
  wwSlider.step = "1";
}

function storageKey(mod, base){
  return `wl_${base}_${mod || "OTHER"}`;
}

/* -------------------------
   Cine controls
   ------------------------- */
async function setIndex(vp, idx){
  if (!vp) return;
  try{
    if (typeof vp.setImageIdIndex === "function") {
      await vp.setImageIdIndex(idx);
    } else if (typeof vp.setImageIndex === "function") {
      await vp.setImageIndex(idx);
    } else if (typeof vp.scroll === "function") {
      const cur = getCurrentIndex(vp);
      vp.scroll(idx - cur);
    }
    if (typeof vp.render === "function") vp.render();
  }catch(e){
    console.warn("[Cine] set index failed:", e);
  }

  if (window.__SLICE_COUNTER_EL__) updateSliceCounter(window.__SLICE_COUNTER_EL__);
}

function installCineControls(groupEl){
  let playing = false;
  let timer = null;

  const cineBtn = document.createElement("button");
  cineBtn.className = "btn small";
  cineBtn.type = "button";
  cineBtn.textContent = "Cine";

  const stepBack = document.createElement("button");
  stepBack.className = "btn small";
  stepBack.type = "button";
  stepBack.textContent = "Prev";

  const stepFwd = document.createElement("button");
  stepFwd.className = "btn small";
  stepFwd.type = "button";
  stepFwd.textContent = "Next";

  const fpsWrap = document.createElement("span");
  fpsWrap.className = "cineFps";
  fpsWrap.innerHTML = `<span class="cineMini">FPS</span>`;

  const slider = document.createElement("input");
  slider.className = "cineSlider";
  slider.type = "range";
  slider.min = "1";
  slider.max = "30";
  slider.step = "1";
  slider.value = "12";

  const fpsVal = document.createElement("span");
  fpsVal.className = "cineMini";
  fpsVal.textContent = slider.value;

  fpsWrap.appendChild(slider);
  fpsWrap.appendChild(fpsVal);

  function stop(){
    playing = false;
    cineBtn.textContent = "Cine";
    if (timer) { clearInterval(timer); timer = null; }
  }

  async function tick(){
    const vp = getViewport();
    if (!vp) { stop(); return; }

    const n = getStackSize(vp);
    if (!n) { stop(); return; }

    const cur = getCurrentIndex(vp);
    const next = (cur + 1) % n;
    await setIndex(vp, next);
  }

  function start(){
    const vp = getViewport();
    if (!vp) { console.warn("[Cine] Missing viewport context."); return; }
    const n = getStackSize(vp);
    if (!n) { console.warn("[Cine] No stack loaded."); return; }

    playing = true;
    cineBtn.textContent = "Pause";

    const fps = Number(slider.value) || 12;
    const interval = Math.max(20, Math.round(1000 / fps));

    if (timer) clearInterval(timer);
    timer = setInterval(() => { tick(); }, interval);
  }

  cineBtn.addEventListener("click", () => { if (playing) stop(); else start(); });

  slider.addEventListener("input", () => {
    fpsVal.textContent = slider.value;
    if (playing) { stop(); start(); }
  });

  stepBack.addEventListener("click", async () => {
    const vp = getViewport();
    if (!vp) return;
    const n = getStackSize(vp);
    if (!n) return;
    const cur = getCurrentIndex(vp);
    const next = (cur - 1 + n) % n;
    await setIndex(vp, next);
  });

  stepFwd.addEventListener("click", async () => {
    const vp = getViewport();
    if (!vp) return;
    const n = getStackSize(vp);
    if (!n) return;
    const cur = getCurrentIndex(vp);
    const next = (cur + 1) % n;
    await setIndex(vp, next);
  });

  groupEl.appendChild(cineBtn);
  groupEl.appendChild(stepBack);
  groupEl.appendChild(stepFwd);
  groupEl.appendChild(fpsWrap);
}

/* -------------------------
   AI results auto-wire (fetch interceptor)
   ------------------------- */
function normalizeFindings(data){
  if (Array.isArray(data)) return data.map((d, idx) => normalizeOne(d, idx));

  const root = data && typeof data === "object" ? data : {};
  const list =
    root.findings ??
    root.detections ??
    root.predictions ??
    root.results ??
    root.output ??
    [];

  return safeArray(list).map((d, idx) => normalizeOne(d, idx));
}

function normalizeOne(d, idx){
  const o = d && typeof d === "object" ? d : {};
  const id = o.id ?? o.uid ?? o.nameId ?? `f${idx + 1}`;
  const label = o.label ?? o.type ?? o.class ?? o.name ?? "Finding";
  const score =
    (typeof o.score === "number") ? o.score :
    (typeof o.confidence === "number") ? o.confidence :
    (typeof o.prob === "number") ? o.prob :
    null;

  const sliceIndex = (o.sliceIndex ?? o.slice ?? o.z ?? o.frame ?? null);
  const bbox = (o.bbox ?? o.box ?? o.boundingBox ?? null);

  return { id: String(id), label: String(label), score, sliceIndex, bbox };
}

function publishResults(findings){
  const arr = safeArray(findings);
  window.dispatchEvent(new CustomEvent("ai:results", { detail: arr }));
  if (typeof window.setAIResults === "function") {
    try{ window.setAIResults(arr); }catch(e){}
  }
}

function installFetchInterceptor(){
  if (window.__AI_FETCH_INTERCEPTOR__) return;
  window.__AI_FETCH_INTERCEPTOR__ = true;

  const origFetch = window.fetch;
  if (typeof origFetch !== "function") return;

  window.fetch = async (...args) => {
    const res = await origFetch(...args);

    try{
      const ct = (res.headers && res.headers.get) ? (res.headers.get("content-type") || "") : "";
      if (!ct.toLowerCase().includes("application/json")) return res;

      const clone = res.clone();
      const data = await clone.json();

      const root = data && typeof data === "object" ? data : null;
      const hasLikelyKeys = root && (
        ("findings" in root) ||
        ("detections" in root) ||
        ("predictions" in root) ||
        ("results" in root)
      );

      if (hasLikelyKeys || Array.isArray(data)) {
        const findings = normalizeFindings(data);
        if (findings.length) publishResults(findings);
      }
    }catch(e){
      // ignore
    }

    return res;
  };
}

/* -------------------------
   Insert toolbar controls
   ------------------------- */
function findAIAnalyzeButton(){
  const buttons = $all("button");
  return buttons.find(b => toLower(b.textContent).replace(/\s+/g, " ").includes("ai analyze")) || null;
}

function insertToolbarControls(){
  if (document.getElementById("toolbarControlsGroup")) return;

  const analyzeBtn = findAIAnalyzeButton();
  if (!analyzeBtn) {
    console.warn("[Toolbar Controls] Could not find the 'AI Analyze' button. Controls will be added at end of body.");
  }

  const host = analyzeBtn ? (analyzeBtn.parentElement || document.body) : document.body;

  const group = document.createElement("span");
  group.id = "toolbarControlsGroup";
  group.className = "toolbarControlsGroup";

  // Results button
  const resultsBtn = document.createElement("button");
  resultsBtn.id = "aiResultsDockBtn";
  resultsBtn.className = "btn small aiResultsDockBtn";
  resultsBtn.type = "button";
  resultsBtn.title = "AI Results";
  resultsBtn.innerHTML = `Results <span id="aiResultsDockCount" class="aiResultsDockCount">0</span>`;
  resultsBtn.addEventListener("click", () => toggleResultsPanel());

  // Reset View button
  const resetBtn = document.createElement("button");
  resetBtn.className = "btn small";
  resetBtn.type = "button";
  resetBtn.title = "Reset view (zoom, pan, window level)";
  resetBtn.textContent = "Reset View";
  resetBtn.addEventListener("click", () => resetView());

  // Transform buttons
  const invertBtn = document.createElement("button");
  invertBtn.className = "btn small";
  invertBtn.type = "button";
  invertBtn.title = "Invert";
  invertBtn.textContent = "Invert";
  invertBtn.addEventListener("click", () => toggleInvert(invertBtn));

  const rotBtn = document.createElement("button");
  rotBtn.className = "btn small";
  rotBtn.type = "button";
  rotBtn.title = "Rotate 90 degrees";
  rotBtn.textContent = "Rotate";
  rotBtn.addEventListener("click", () => rotate90());

  const flipHBtn = document.createElement("button");
  flipHBtn.className = "btn small";
  flipHBtn.type = "button";
  flipHBtn.title = "Flip horizontal";
  flipHBtn.textContent = "Flip H";
  flipHBtn.addEventListener("click", () => flipH(flipHBtn));

  const flipVBtn = document.createElement("button");
  flipVBtn.className = "btn small";
  flipVBtn.type = "button";
  flipVBtn.title = "Flip vertical";
  flipVBtn.textContent = "Flip V";
  flipVBtn.addEventListener("click", () => flipV(flipVBtn));

  // Modality badge
  const modalityBadge = document.createElement("span");
  modalityBadge.id = "modalityBadge";
  modalityBadge.className = "modalityBadge";
  modalityBadge.textContent = "OTHER";

  // W/L wrap: dropdown + sliders
  const wlWrap = document.createElement("span");
  wlWrap.className = "wlWrap";

  const wlSelect = document.createElement("select");
  wlSelect.className = "wlSelect";
  wlSelect.title = "Window/Level preset";

  const wlSliders = document.createElement("span");
  wlSliders.className = "wlSliders";

  const wlSliderWrap = document.createElement("span");
  wlSliderWrap.className = "wlSliderWrap";
  wlSliderWrap.innerHTML = `<span class="wlMini">WL</span>`;

  const wlSlider = document.createElement("input");
  wlSlider.className = "wlSlider";
  wlSlider.type = "range";

  const wlVal = document.createElement("span");
  wlVal.className = "wlMini";
  wlVal.textContent = "0";

  wlSliderWrap.appendChild(wlSlider);
  wlSliderWrap.appendChild(wlVal);

  const wwSliderWrap = document.createElement("span");
  wwSliderWrap.className = "wlSliderWrap";
  wwSliderWrap.innerHTML = `<span class="wlMini">WW</span>`;

  const wwSlider = document.createElement("input");
  wwSlider.className = "wlSlider";
  wwSlider.type = "range";

  const wwVal = document.createElement("span");
  wwVal.className = "wlMini";
  wwVal.textContent = "0";

  wwSliderWrap.appendChild(wwSlider);
  wwSliderWrap.appendChild(wwVal);

  wlSliders.appendChild(wlSliderWrap);
  wlSliders.appendChild(wwSliderWrap);

  wlWrap.appendChild(wlSelect);
  wlWrap.appendChild(wlSliders);

  // Slice counter
  const counterEl = document.createElement("span");
  counterEl.id = "sliceCounter";
  counterEl.className = "sliceCounter";
  counterEl.textContent = "-- / --";
  window.__SLICE_COUNTER_EL__ = counterEl;

  group.appendChild(resultsBtn);
  group.appendChild(resetBtn);
  group.appendChild(invertBtn);
  group.appendChild(rotBtn);
  group.appendChild(flipHBtn);
  group.appendChild(flipVBtn);
  group.appendChild(modalityBadge);
  group.appendChild(wlWrap);
  group.appendChild(counterEl);

  // Cine controls
  installCineControls(group);

  if (analyzeBtn && analyzeBtn.parentElement) {
    analyzeBtn.insertAdjacentElement("afterend", group);
  } else {
    host.appendChild(group);
  }

  installBadgeWiring();
  installSliceCounterWiring(counterEl);

  // W/L logic
  let dragging = false;

  function setSelectOptions(mod){
    const options = [];

    options.push({ key: "default", label: "W/L: Default" });

    if (mod === "CT") {
      options.push({ key: "brain",   label: "CT Brain (70/35)" });
      options.push({ key: "soft",    label: "Soft Tissue (350/50)" });
      options.push({ key: "lung",    label: "Lung (1500/-600)" });
      options.push({ key: "bone",    label: "Bone (2500/500)" });
      options.push({ key: "abdomen", label: "Abdomen (400/50)" });
      options.push({ key: "liver",   label: "Liver (150/30)" });
      options.push({ key: "custom",  label: "Custom (sliders)" });
    } else if (mod === "MR") {
      options.push({ key: "mr_low",  label: "MR Low contrast" });
      options.push({ key: "mr_high", label: "MR High contrast" });
      options.push({ key: "custom",  label: "Custom (sliders)" });
    } else {
      options.push({ key: "custom",  label: "Custom (sliders)" });
    }

    wlSelect.innerHTML = options.map(o => `<option value="${o.key}">${o.label}</option>`).join("");
  }

  function setSliderDisplays(){
    wlVal.textContent = String(Math.round(Number(wlSlider.value) || 0));
    wwVal.textContent = String(Math.round(Number(wwSlider.value) || 0));
  }

  function loadSaved(mod){
    const preset = store.get(storageKey(mod, "preset"), "default");
    const wl = Number(store.get(storageKey(mod, "wl"), "0"));
    const ww = Number(store.get(storageKey(mod, "ww"), "800"));
    return { preset, wl, ww };
  }

  function saveManual(mod){
    store.set(storageKey(mod, "wl"), wlSlider.value);
    store.set(storageKey(mod, "ww"), wwSlider.value);
    store.set(storageKey(mod, "preset"), "custom");
  }

  function applyMRContrast(kind){
    const vp = getViewport();
    const current = voiToWL(getCurrentVOI(vp));
    if (!current) return;

    const factor = (kind === "mr_high") ? 0.7 : 1.4;
    const ww = Math.max(1, current.ww * factor);
    const wl = current.wl;

    wwSlider.value = String(Math.round(ww));
    wlSlider.value = String(Math.round(wl));
    setSliderDisplays();

    applyVOIRangeFromWL(wwSlider.value, wlSlider.value);
  }

  function applyPreset(mod, key){
    if (key === "default") {
      resetView();
      store.set(storageKey(mod, "preset"), "default");
      setTimeout(() => syncFromViewport(mod), 250);
      return;
    }

    if (mod === "CT") {
      if (key === "custom") {
        const saved = loadSaved(mod);
        if (Number.isFinite(saved.ww) && saved.ww > 0) wwSlider.value = String(Math.round(saved.ww));
        if (Number.isFinite(saved.wl)) wlSlider.value = String(Math.round(saved.wl));
        setSliderDisplays();
        applyVOIRangeFromWL(wwSlider.value, wlSlider.value);
        store.set(storageKey(mod, "preset"), "custom");
        return;
      }

      const wl = ctPresetToWL(key);
      if (!wl) return;

      wwSlider.value = String(wl.ww);
      wlSlider.value = String(wl.wl);
      setSliderDisplays();
      applyVOIRangeFromWL(wl.ww, wl.wl);
      store.set(storageKey(mod, "preset"), key);
      return;
    }

    if (mod === "MR") {
      if (key === "custom") {
        const saved = loadSaved(mod);
        if (Number.isFinite(saved.ww) && saved.ww > 0) wwSlider.value = String(Math.round(saved.ww));
        if (Number.isFinite(saved.wl)) wlSlider.value = String(Math.round(saved.wl));
        setSliderDisplays();
        applyVOIRangeFromWL(wwSlider.value, wlSlider.value);
        store.set(storageKey(mod, "preset"), "custom");
        return;
      }

      if (key === "mr_low" || key === "mr_high") {
        applyMRContrast(key);
        store.set(storageKey(mod, "preset"), key);
      }
      return;
    }

    // OTHER
    if (key === "custom") {
      const saved = loadSaved(mod);
      if (Number.isFinite(saved.ww) && saved.ww > 0) wwSlider.value = String(Math.round(saved.ww));
      if (Number.isFinite(saved.wl)) wlSlider.value = String(Math.round(saved.wl));
      setSliderDisplays();
      applyVOIRangeFromWL(wwSlider.value, wlSlider.value);
      store.set(storageKey(mod, "preset"), "custom");
    }
  }

  function syncFromViewport(mod){
    const vp = getViewport();
    const wl = voiToWL(getCurrentVOI(vp));
    if (!wl) return;

    if (dragging) return;

    const curWL = Number(wlSlider.value);
    const curWW = Number(wwSlider.value);

    const nextWL = Math.round(wl.wl);
    const nextWW = Math.round(wl.ww);

    setSliderRanges(mod, wlSlider, wwSlider);

    if (Math.abs(curWL - nextWL) > 2) wlSlider.value = String(nextWL);
    if (Math.abs(curWW - nextWW) > 2) wwSlider.value = String(nextWW);

    setSliderDisplays();
  }

  function initWL(){
    const mod = detectModality();
    window.__WL_MODALITY__ = mod;
    modalityBadge.textContent = mod;

    setSelectOptions(mod);
    setSliderRanges(mod, wlSlider, wwSlider);

    const saved = loadSaved(mod);

    const vp = getViewport();
    const current = voiToWL(getCurrentVOI(vp));
    const seedWL = current ? Math.round(current.wl) : (Number.isFinite(saved.wl) ? Math.round(saved.wl) : 0);
    const seedWW = current ? Math.round(current.ww) : (Number.isFinite(saved.ww) && saved.ww > 0 ? Math.round(saved.ww) : 800);

    wlSlider.value = String(seedWL);
    wwSlider.value = String(seedWW);
    setSliderDisplays();

    const preset = saved.preset || "default";
    wlSelect.value = preset;

    setTimeout(() => applyPreset(mod, wlSelect.value || "default"), 300);
  }

  wlSlider.addEventListener("pointerdown", () => { dragging = true; });
  wwSlider.addEventListener("pointerdown", () => { dragging = true; });
  window.addEventListener("pointerup", () => { dragging = false; });

  wlSlider.addEventListener("input", () => {
    setSliderDisplays();
    const mod = detectModality();
    if (wlSelect.value !== "custom") wlSelect.value = "custom";
    applyVOIRangeFromWL(wwSlider.value, wlSlider.value);
    saveManual(mod);
  });

  wwSlider.addEventListener("input", () => {
    setSliderDisplays();
    const mod = detectModality();
    if (wlSelect.value !== "custom") wlSelect.value = "custom";
    applyVOIRangeFromWL(wwSlider.value, wlSlider.value);
    saveManual(mod);
  });

  wlSelect.addEventListener("change", () => {
    const mod = detectModality();
    store.set(storageKey(mod, "preset"), wlSelect.value || "default");
    applyPreset(mod, wlSelect.value || "default");
  });

  // Keep UI synced, detect modality changes
  let lastMod = detectModality();
  setInterval(() => {
    const mod = detectModality();
    if (mod !== lastMod) {
      lastMod = mod;
      window.__WL_MODALITY__ = mod;
      modalityBadge.textContent = mod;

      setSelectOptions(mod);
      setSliderRanges(mod, wlSlider, wwSlider);

      const saved = loadSaved(mod);
      wlSelect.value = saved.preset || "default";
      applyPreset(mod, wlSelect.value || "default");
    } else {
      modalityBadge.textContent = mod;
    }

    syncFromViewport(mod);
  }, 350);

  // Hotkeys (optional)
  document.addEventListener("keydown", (e) => {
    const k = String(e.key || "").toLowerCase();
    if (k === "i") toggleInvert(invertBtn);
    if (k === "r") rotate90();
    if (k === "h") flipH(flipHBtn);
    if (k === "v") flipV(flipVBtn);
  });

  initWL();
}

document.addEventListener("DOMContentLoaded", () => {
  try{
    insertToolbarControls();
    installFetchInterceptor();
  }catch(e){
    console.warn("[Toolbar Controls] init failed:", e);
  }
});
