/**
 * Toolbar Controls Pack
 * - Inserts buttons next to the existing "AI Analyze" button (by text match)
 * - Results button toggles the AI Results panel (aiResultsPanel)
 * - Reset View: best-effort reset for Cornerstone viewport
 * - Cine: play slices with FPS slider + step buttons
 * - Auto-wire AI results: intercept fetch JSON and dispatch ai:results
 *
 * Requirements for Reset/Cine to work:
 *   Your main app should expose these once the viewport exists:
 *     window.__CS_RENDERING_ENGINE__ = renderingEngine;
 *     window.__CS_VIEWPORT_ID__ = viewportId;
 */

function $(sel, root = document){ return root.querySelector(sel); }
function $all(sel, root = document){ return Array.from(root.querySelectorAll(sel)); }

function getCornerstoneContext(){
  return {
    renderingEngine: window.__CS_RENDERING_ENGINE__ || null,
    viewportId: window.__CS_VIEWPORT_ID__ || null
  };
}

function getViewport(){
  const ctx = getCornerstoneContext();
  if (!ctx.renderingEngine || !ctx.viewportId) return null;
  try{
    return ctx.renderingEngine.getViewport(ctx.viewportId) || null;
  }catch(e){
    return null;
  }
}

function safeArray(x){ return Array.isArray(x) ? x : []; }
function toLower(x){ return String(x ?? "").toLowerCase(); }
function isNum(x){ return Number.isFinite(Number(x)); }

function normalizeFindings(data){
  // Accept many common shapes
  if (Array.isArray(data)) {
    return data.map((d, idx) => normalizeOne(d, idx));
  }

  const root = data && typeof data === "object" ? data : {};
  const list =
    root.findings ??
    root.detections ??
    root.predictions ??
    root.results ??
    root.output ??
    [];

  return safeArray(list).map((d, idx) => normalizeOne(d, idx));
}

function normalizeOne(d, idx){
  const o = d && typeof d === "object" ? d : {};
  const id =
    o.id ??
    o.uid ??
    o.nameId ??
    `f${idx + 1}`;

  const label =
    o.label ??
    o.type ??
    o.class ??
    o.name ??
    "Finding";

  const score =
    (typeof o.score === "number") ? o.score :
    (typeof o.confidence === "number") ? o.confidence :
    (typeof o.prob === "number") ? o.prob :
    null;

  const sliceIndex =
    (o.sliceIndex ?? o.slice ?? o.z ?? o.frame ?? null);

  const bbox =
    (o.bbox ?? o.box ?? o.boundingBox ?? null);

  return { id: String(id), label: String(label), score, sliceIndex, bbox };
}

function publishResults(findings){
  const arr = safeArray(findings);
  // Panel listens for this
  window.dispatchEvent(new CustomEvent("ai:results", { detail: arr }));
  // If panel is using window.setAIResults, call it too (optional)
  if (typeof window.setAIResults === "function") {
    try{ window.setAIResults(arr); }catch(e){}
  }
}

function toggleResultsPanel(){
  const panel = document.getElementById("aiResultsPanel");
  if (!panel) return;

  panel.classList.toggle("is-collapsed");
  const collapsed = panel.classList.contains("is-collapsed");
  panel.style.pointerEvents = collapsed ? "none" : "auto";
  panel.style.opacity = collapsed ? "0" : "1";
}

function setBadgeCount(n){
  const el = document.getElementById("aiResultsDockCount");
  if (!el) return;
  el.textContent = String(Math.max(0, Number(n) || 0));
}

function installBadgeWiring(){
  // Update on ai:results events
  window.addEventListener("ai:results", (e) => {
    const arr = e && e.detail ? e.detail : [];
    setBadgeCount(safeArray(arr).length);
  });

  // Also wrap setAIResults once it exists (so count updates even if caller uses setAIResults directly)
  const t = setInterval(() => {
    if (window.__AI_RESULTS_WRAPPED__) { clearInterval(t); return; }
    if (typeof window.setAIResults === "function") {
      const orig = window.setAIResults;
      window.setAIResults = (findings) => {
        const arr = safeArray(findings);
        setBadgeCount(arr.length);
        return orig(arr);
      };
      window.__AI_RESULTS_WRAPPED__ = true;
      clearInterval(t);
    }
  }, 400);
}

function resetView(){
  const vp = getViewport();
  if (!vp) {
    console.warn("[Reset View] Missing viewport. Set window.__CS_RENDERING_ENGINE__ and window.__CS_VIEWPORT_ID__.");
    return;
  }

  try{
    // Best effort, depending on viewport implementation
    if (typeof vp.resetCamera === "function") vp.resetCamera();
    if (typeof vp.resetProperties === "function") vp.resetProperties();

    // Fallbacks if above are not present
    if (typeof vp.setZoom === "function") vp.setZoom(1);
    if (typeof vp.setPan === "function") vp.setPan({ x: 0, y: 0 });

    if (typeof vp.render === "function") vp.render();
  }catch(e){
    console.warn("[Reset View] failed:", e);
  }
}

function getStackSize(vp){
  try{
    if (typeof vp.getImageIds === "function") {
      const ids = vp.getImageIds();
      return safeArray(ids).length;
    }
  }catch(e){}
  // fallback if your app stores it
  if (Array.isArray(window.__STACK_IMAGE_IDS__)) return window.__STACK_IMAGE_IDS__.length;
  return 0;
}

function getCurrentIndex(vp){
  try{
    if (typeof vp.getCurrentImageIdIndex === "function") return Number(vp.getCurrentImageIdIndex()) || 0;
    if (typeof vp.getImageIdIndex === "function") return Number(vp.getImageIdIndex()) || 0;
  }catch(e){}
  return 0;
}

async function setIndex(vp, idx){
  if (!vp) return;
  try{
    if (typeof vp.setImageIdIndex === "function") {
      await vp.setImageIdIndex(idx);
    } else if (typeof vp.setImageIndex === "function") {
      await vp.setImageIndex(idx);
    } else if (typeof vp.scroll === "function") {
      const cur = getCurrentIndex(vp);
      vp.scroll(idx - cur);
    }
    if (typeof vp.render === "function") vp.render();
  }catch(e){
    console.warn("[Cine] set index failed:", e);
  }
}

function installCineControls(groupEl){
  let playing = false;
  let timer = null;

  const cineBtn = document.createElement("button");
  cineBtn.className = "btn small";
  cineBtn.type = "button";
  cineBtn.textContent = "Cine";

  const stepBack = document.createElement("button");
  stepBack.className = "btn small";
  stepBack.type = "button";
  stepBack.textContent = "";

  const stepFwd = document.createElement("button");
  stepFwd.className = "btn small";
  stepFwd.type = "button";
  stepFwd.textContent = "";

  const fpsWrap = document.createElement("span");
  fpsWrap.className = "cineFps";
  fpsWrap.innerHTML = `<span class="cineMini">FPS</span>`;

  const slider = document.createElement("input");
  slider.className = "cineSlider";
  slider.type = "range";
  slider.min = "1";
  slider.max = "30";
  slider.step = "1";
  slider.value = "12";

  const fpsVal = document.createElement("span");
  fpsVal.className = "cineMini";
  fpsVal.textContent = slider.value;

  fpsWrap.appendChild(slider);
  fpsWrap.appendChild(fpsVal);

  function stop(){
    playing = false;
    cineBtn.textContent = "Cine";
    if (timer) { clearInterval(timer); timer = null; }
  }

  async function tick(){
    const vp = getViewport();
    if (!vp) { stop(); return; }

    const n = getStackSize(vp);
    if (!n) { stop(); return; }

    const cur = getCurrentIndex(vp);
    const next = (cur + 1) % n;
    await setIndex(vp, next);
  }

  function start(){
    const vp = getViewport();
    if (!vp) { console.warn("[Cine] Missing viewport context."); return; }
    const n = getStackSize(vp);
    if (!n) { console.warn("[Cine] No stack loaded."); return; }

    playing = true;
    cineBtn.textContent = "Pause";

    const fps = Number(slider.value) || 12;
    const interval = Math.max(20, Math.round(1000 / fps));

    if (timer) clearInterval(timer);
    timer = setInterval(() => { tick(); }, interval);
  }

  cineBtn.addEventListener("click", () => {
    if (playing) stop(); else start();
  });

  slider.addEventListener("input", () => {
    fpsVal.textContent = slider.value;
    if (playing) { stop(); start(); }
  });

  stepBack.addEventListener("click", async () => {
    const vp = getViewport();
    if (!vp) return;
    const n = getStackSize(vp);
    if (!n) return;
    const cur = getCurrentIndex(vp);
    const next = (cur - 1 + n) % n;
    await setIndex(vp, next);
  });

  stepFwd.addEventListener("click", async () => {
    const vp = getViewport();
    if (!vp) return;
    const n = getStackSize(vp);
    if (!n) return;
    const cur = getCurrentIndex(vp);
    const next = (cur + 1) % n;
    await setIndex(vp, next);
  });

  groupEl.appendChild(cineBtn);
  groupEl.appendChild(stepBack);
  groupEl.appendChild(stepFwd);
  groupEl.appendChild(fpsWrap);
}

function findAIAnalyzeButton(){
  const buttons = $all("button");
  // Match by visible text, works even if HTML structure changed
  return buttons.find(b => toLower(b.textContent).replace(/\s+/g, " ").includes("ai analyze")) || null;
}

function insertToolbarControls(){
  const analyzeBtn = findAIAnalyzeButton();
  if (!analyzeBtn) {
    console.warn("[Toolbar Controls] Could not find the 'AI Analyze' button. Controls will be added at end of body.");
  }

  // Decide where to insert
  const host = analyzeBtn ? (analyzeBtn.parentElement || document.body) : document.body;

  // Group wrapper
  const group = document.createElement("span");
  group.className = "toolbarControlsGroup";

  // Results button (with badge)
  const resultsBtn = document.createElement("button");
  resultsBtn.id = "aiResultsDockBtn";
  resultsBtn.className = "btn small aiResultsDockBtn";
  resultsBtn.type = "button";
  resultsBtn.title = "AI Results";
  resultsBtn.innerHTML = `Results <span id="aiResultsDockCount" class="aiResultsDockCount">0</span>`;
  resultsBtn.addEventListener("click", () => toggleResultsPanel());

  // Reset View button
  const resetBtn = document.createElement("button");
  resetBtn.className = "btn small";
  resetBtn.type = "button";
  resetBtn.title = "Reset view (zoom, pan, window level)";
  resetBtn.textContent = "Reset View";
  resetBtn.addEventListener("click", () => resetView());

  group.appendChild(resultsBtn);
  group.appendChild(resetBtn);

  // Cine controls
  installCineControls(group);

  // Insert next to Analyze
  if (analyzeBtn && analyzeBtn.parentElement) {
    analyzeBtn.insertAdjacentElement("afterend", group);
  } else {
    document.body.appendChild(group);
  }

  installBadgeWiring();
}

function installFetchInterceptor(){
  if (window.__AI_FETCH_INTERCEPTOR__) return;
  window.__AI_FETCH_INTERCEPTOR__ = true;

  const origFetch = window.fetch;
  if (typeof origFetch !== "function") return;

  window.fetch = async (...args) => {
    const res = await origFetch(...args);

    try{
      const ct = (res.headers && res.headers.get) ? (res.headers.get("content-type") || "") : "";
      if (!ct.toLowerCase().includes("application/json")) return res;

      // Clone so the app can still read the original response
      const clone = res.clone();
      const data = await clone.json();

      // Heuristic: only publish if it looks like AI output
      const root = data && typeof data === "object" ? data : null;
      const hasLikelyKeys = root && (
        ("findings" in root) ||
        ("detections" in root) ||
        ("predictions" in root) ||
        ("results" in root)
      );

      if (hasLikelyKeys || Array.isArray(data)) {
        const findings = normalizeFindings(data);
        if (findings.length) publishResults(findings);
      }
    }catch(e){
      // ignore
    }

    return res;
  };
}

document.addEventListener("DOMContentLoaded", () => {
  try{
    insertToolbarControls();
    installFetchInterceptor();
  }catch(e){
    console.warn("[Toolbar Controls] init failed:", e);
  }
});
